Logging (Логирование)
Логирование - это процесс записи сообщений, которые могут быть полезны
для отслеживания выполнения программы, отладки и анализа ошибок.

Основные концепции логирования:
Логгеры (loggers) - компоненты, которые вызывают запись сообщений.
Обработчики (handlers) - компоненты, которые определяют, куда будут
отправляться лог-сообщений (файл, консоль и т.д.)
Фильтры (filters) - компоненты, которые позволяют фильтровать лог-сообщений
чтобы определенные сообщения записывались только при выполнении определенных
условий.

Уровни логирования (logging levels) - определяют важность лог-сообщения:
Debug
Info
Warning
Error
Critical


Кэширование - это процесс сохранения вычислительных данных для повторного
использования, чтобы уменьшить время отклика и нагрузку на сервер



Celery - это мощный иструмент для выполнения задач в фоновом режиме, легко интегриругется
с Django. Он помогает разгрузить основной поток выполенения и улучшить производительность
нашего приложения (особенно для выполнения длительных операций: отправка писем, подсчет чего
либо и другие)
Основные функции:
1. Асинхронное выполнение задач
2. Повышение производительности
3. Масштабируемость
4. Надежность выполнения задач и повторное выполнение задач в случае ошибки
5. Отслеживание и мониторинг задач


Docker - это платформа для разработки, позволяет запускать приложения в контейнерах.
Контейнеры представляют собой изолированные среды, в которых запускаются приложения и
их зависимости

Docker Engine - основной компонент, который отвечает за создание и управление контейнерами,
движок который управялет контейнерами

Основные компоненты:
Docker Images (Образы) - шаблоны, содержащие все необходимое для запуска приложения, включая
код, библиотеки, зависимости и настройки. Образы неизменяеумы и могут быть сохранены в
реестре образов (Docker Registry) для последующего использования
Docker Containers (Контейнеры) - запущенный экземпялр Docker images, которые изолированы
от нашей операционной системы и других контейнеров.
Volumes (Том) - это механизм хранения данных в Docker


Dockerfile - текстовый файл, содержащий набор инструкций для создания Docker-образа.
Docker Compose - инструмент для определения и управления несколькими dockerfile(образами)
Позволяет управлять многоконтейнерными Docker-приложениями
Docker-hub - облачный реестр Docker-образов, позволяющий пользователям загружать, сохранять
и обмениваться образами


Основные команды Docker:
docker images - показывает установленные образы
docker ps - показывает текущие контейнеры которые работают
docker ps -a  - показывает все контейнеры
docker run 'Name images' - скачивает образ, и запускает контейнер

docker stop 'Conteiner_ID' - останавливает контейнер
docker start 'Conteiner_ID' - запускает контейнер
docker kill 'Conteiner_ID' - убивает (завершает работу) контейнера
docker rm 'Conteiner_ID' - удаляет контейнер
docker rmi 'Name images' - удаляет образ
docker exec -it 'Conteiner_ID' bash - запускает терминал запущенного контейнера


docker build - создание образа из dockerfile
docker pull - скачивает образ с docker hub
docker push - отправляет образ в docker hub

Docker compose:
docker-compose up - запуск сервисов
docker-compose down - остановка сервисов
docker-compose ps - просмотр всех запущенных сервисов
docker-compose build - создание сервиса из docker-compose


Dockerfile:
FROM - главный образ с которого идет сборка
MAINTAINER name <mail> - кто собрал образ
RUN - запускает команды
CMD - запускает процессы
COPY - копирует файлы из нашего хоста(операционной системы) в внутрь контейнера,
например:  . (указывается расположение хоста) /app (указывается куда будут скопированы файлы
внутри контейнера)
EXPOSE - открыть порт
WORKDIR - устанавливает рабочую директорию, мы попадаем в нее при заходе внутрь контейнера



FROM python:3
задает базовый образ для сборки

ENV PYTHONIOENCODING UTF-8  - устанавливает кодировку по умолчанию
ENV TZ=Asia/Bishkek - устанавливает временную зону
эти команды устанавливают переменные окружения

RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo > /etc/timezone

WORKDIR /usr/src/app
устанавливает рабочую директорию

COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

RUN mkdir static && mkdir media
COPY . .

RUN python3 manage.py collecstatic --noinput

RUN chmod -R 755 /ursr/src/app/static

EXPOSE 8000